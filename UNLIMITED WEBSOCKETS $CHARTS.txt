UNLIMITED WEBSOCKETS $CHARTS

import { Server as SocketIOServer, Socket } from 'socket.io'; import { CacheService } from './cache'; import { Trade, Ticker, OrderBook, WebSocketMessage, TradeUpdate, TickerUpdate, OrderBookUpdate } from '@/types'; export class WebSocketService { private io: SocketIOServer; private cache: CacheService; private activeConnections: Set<Socket> = new Set(); private marketSubscriptions: Map<string, Set<Socket>> = new Map(); constructor(io: SocketIOServer, cache: CacheService) { this.io = io; this.cache = cache; } async initialize(): Promise<void> { // Set up WebSocket event handlers this.io.on('connection', (socket: Socket) => { console.log(Client connected: ${socket.id}); this.activeConnections.add(socket); // Handle client subscriptions socket.on('subscribe', (data: { channel: string; market?: string }) => { this.handleSubscribe(socket, data); }); socket.on('unsubscribe', (data: { channel: string; market?: string }) => { this.handleUnsubscribe(socket, data); }); socket.on('ping', () => { socket.emit('pong', { timestamp: Date.now() }); }); socket.on('disconnect', (reason: string) => { console.log(Client disconnected: ${socket.id}, reason: ${reason}); this.handleDisconnect(socket); }); socket.on('error', (error: Error) => { console.error(Socket error for ${socket.id}:, error); }); // Send welcome message socket.emit('welcome', { type: 'system', message: 'Connected to AIQuantum Charts WebSocket', timestamp: Date.now(), channels: [ 'trades:MARKET_ID', 'ticker:MARKET_ID', 'orderbook:MARKET_ID', 'system' ] }); }); // Subscribe to Redis pub/sub for real-time updates await this.subscribeToRedisChannels(); console.log('WebSocket service initialized'); } private handleSubscribe(socket: Socket, data: { channel: string; market?: string }): void { try { const { channel, market } = data; if (!this.isValidChannel(channel)) { socket.emit('error', { type: 'subscription_error', message: 'Invalid channel', timestamp: Date.now() }); return; } const channelKey = market ? ${channel}:${market.toUpperCase()} : channel; // Add to room socket.join(channelKey); // Track market subscriptions if (market) { if (!this.marketSubscriptions.has(market.toUpperCase())) { this.marketSubscriptions.set(market.toUpperCase(), new Set()); } this.marketSubscriptions.get(market.toUpperCase())?.add(socket); } socket.emit('subscribed', { type: 'subscription_success', channel: channelKey, timestamp: Date.now() }); console.log(Client ${socket.id} subscribed to ${channelKey}); // Send initial data if available this.sendInitialData(socket, channel, market); } catch (error) { console.error('Subscription error:', error); socket.emit('error', { type: 'subscription_error', message: 'Failed to subscribe', timestamp: Date.now() }); } } private handleUnsubscribe(socket: Socket, data: { channel: string; market?: string }): void { try { const { channel, market } = data; const channelKey = market ? ${channel}:${market.toUpperCase()} : channel; // Leave room socket.leave(channelKey); // Remove from market subscriptions if (market) { const marketSockets = this.marketSubscriptions.get(market.toUpperCase()); if (marketSockets) { marketSockets.delete(socket); if (marketSockets.size === 0) { this.marketSubscriptions.delete(market.toUpperCase()); } } } socket.emit('unsubscribed', { type: 'unsubscription_success', channel: channelKey, timestamp: Date.now() }); console.log(Client ${socket.id} unsubscribed from ${channelKey}); } catch (error) { console.error('Unsubscription error:', error); } } private handleDisconnect(socket: Socket): void { this.activeConnections.delete(socket); // Remove from all market subscriptions for (const [market, sockets] of this.marketSubscriptions.entries()) { sockets.delete(socket); if (sockets.size === 0) { this.marketSubscriptions.delete(market); } } } private isValidChannel(channel: string): boolean { const validChannels = ['trades', 'ticker', 'orderbook', 'system']; return validChannels.includes(channel); } private async sendInitialData(socket: Socket, channel: string, market?: string): Promise<void> { if (!market) return; try { const marketId = market.toUpperCase(); switch (channel) { case 'ticker': const ticker = await this.cache.getTicker(marketId); if (ticker) { socket.emit('ticker', { type: 'ticker', channel: ticker:${marketId}, data: this.formatTickerForWS(ticker), timestamp: Date.now() }); } break; case 'trades': const trades = await this.cache.getRecentTrades(marketId, 10); if (trades.length > 0) { trades.forEach(trade => { socket.emit('trade', { type: 'trade', channel: trades:${marketId}, data: this.formatTradeForWS(trade), timestamp: Date.now() }); }); } break; case 'orderbook': const orderbook = await this.cache.getOrderBook(marketId); if (orderbook) { socket.emit('orderbook', { type: 'orderbook', channel: orderbook:${marketId}, data: this.formatOrderBookForWS(orderbook), timestamp: Date.now() }); } break; } } catch (error) { console.error('Error sending initial data:', error); } } // Redis pub/sub handlers private async subscribeToRedisChannels(): Promise<void> { const channels = [ 'market:trades', 'market:ticker', 'market:orderbook' ]; await this.cache.subscribe(channels, (channel: string, message: any) => { this.handleRedisMessage(channel, message); }); } private handleRedisMessage(channel: string, message: any): void { try { const [, type] = channel.split(':'); const marketId = message.marketId || message.market_id; if (!marketId) { console.warn('Received message without marketId:', message); return; } switch (type) { case 'trades': this.broadcastTrade(marketId, message); break; case 'ticker': this.broadcastTicker(marketId, message); break; case 'orderbook': this.broadcastOrderBook(marketId, message); break; } } catch (error) { console.error('Error handling Redis message:', error); } } // Broadcasting methods public broadcastTrade(marketId: string, trade: Trade): void { const channelKey = trades:${marketId.toUpperCase()}; const message: TradeUpdate = { type: 'trade', channel: channelKey, data: this.formatTradeForWS(trade), timestamp: new Date() }; this.io.to(channelKey).emit('trade', message); } public broadcastTicker(marketId: string, ticker: Ticker): void { const channelKey = ticker:${marketId.toUpperCase()}; const message: TickerUpdate = { type: 'ticker', channel: channelKey, data: this.formatTickerForWS(ticker), timestamp: new Date() }; this.io.to(channelKey).emit('ticker', message); } public broadcastOrderBook(marketId: string, orderbook: OrderBook): void { const channelKey = orderbook:${marketId.toUpperCase()}; const message: OrderBookUpdate = { type: 'orderbook', channel: channelKey, data: this.formatOrderBookForWS(orderbook), timestamp: new Date() }; this.io.to(channelKey).emit('orderbook', message); } // Data formatting for WebSocket private formatTradeForWS(trade: Trade): any { return { id: trade.id, market: trade.marketId, price: trade.price.toString(), amount: trade.amount.toString(), side: trade.side, timestamp: trade.timestamp.getTime() }; } private formatTickerForWS(ticker: Ticker): any { return { market: ticker.marketId, last: ticker.last.toString(), bid: ticker.bid.toString(), ask: ticker.ask.toString(), high24h: ticker.high24h.toString(), low24h: ticker.low24h.toString(), volume24h: ticker.volume24h.toString(), change24h: ticker.change24h.toString(), changePercent24h: ticker.changePercent24h.toString(), timestamp: ticker.timestamp.getTime() }; } private formatOrderBookForWS(orderbook: OrderBook): any { return { market: orderbook.marketId, bids: orderbook.bids.map(level => [ level.price.toString(), level.amount.toString() ]), asks: orderbook.asks.map(level => [ level.price.toString(), level.amount.toString() ]), timestamp: orderbook.timestamp.getTime() }; } // Stats and monitoring public getStats(): any { return { activeConnections: this.activeConnections.size, marketSubscriptions: Object.fromEntries( Array.from(this.marketSubscriptions.entries()).map(([market, sockets]) => [ market, sockets.size ]) ), timestamp: Date.now() }; } // System-wide broadcasts public broadcastSystemMessage(message: string, type: string = 'info'): void { this.io.emit('system', { type: 'system', level: type, message, timestamp: Date.now() }); } public async shutdown(): Promise<void> { console.log('Shutting down WebSocket service...'); // Notify all clients this.broadcastSystemMessage('Server shutting down', 'warning'); // Close all connections for (const socket of this.activeConnections) { socket.disconnect(true); } this.activeConnections.clear(); this.marketSubscriptions.clear(); console.log('WebSocket service shutdown complete'); } }
 