charts.ts

import express, { Request, Response } from 'express';
import { Decimal } from 'decimal.js';
import { db } from '@/database';
import { cacheService } from '@/services/cache';
import { CandleInterval, ApiResponse, Trade } from '@/types';

const router = express.Router();

function safeUpperMarketId(marketId: string): string {
  return (marketId || '').trim().toUpperCase();
}

function parseOptionalDate(value: unknown): Date | undefined {
  if (!value) return undefined;
  const d = new Date(String(value));
  if (Number.isNaN(d.getTime())) return undefined;
  return d;
}

function parseIntSafe(value: unknown, fallback: number): number {
  const n = parseInt(String(value ?? ''), 10);
  return Number.isFinite(n) ? n : fallback;
}

function isValidInterval(interval: string): interval is CandleInterval {
  // Works if CandleInterval is a runtime enum/string-enum.
  return Object.values(CandleInterval as any).includes(interval);
}

// Get all markets
router.get('/markets', async (req: Request, res: Response) => {
  try {
    let markets = await cacheService.getMarkets();

    if (!markets) {
      markets = await db.getMarkets();
      await cacheService.setMarkets(markets, 600); // 10 minutes
    }

    const response: ApiResponse<typeof markets> = {
      success: true,
      data: markets,
      timestamp: new Date(),
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching markets:', error);
    res.status(500).json({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch markets' },
      timestamp: new Date(),
    });
  }
});

// Get market details
router.get('/markets/:marketId', async (req: Request, res: Response) => {
  try {
    const marketId = safeUpperMarketId(req.params.marketId);
    const market = await db.getMarket(marketId);

    if (!market) {
      return res.status(404).json({
        success: false,
        error: { code: 'MARKET_NOT_FOUND', message: 'Market not found' },
        timestamp: new Date(),
      });
    }

    const response: ApiResponse<typeof market> = {
      success: true,
      data: market,
      timestamp: new Date(),
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching market:', error);
    res.status(500).json({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch market' },
      timestamp: new Date(),
    });
  }
});

// Get OHLCV candles (main charting endpoint)
router.get('/markets/:marketId/ohlcv', async (req: Request, res: Response) => {
  try {
    const marketId = safeUpperMarketId(req.params.marketId);

    const interval = String(req.query.interval ?? '1h');
    const fromDate = parseOptionalDate(req.query.from);
    const toDate = parseOptionalDate(req.query.to);
    const limitNum = Math.min(parseIntSafe(req.query.limit, 500), 2000);

    if (!isValidInterval(interval)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_INTERVAL',
          message: 'Invalid interval. Supported: 1m, 5m, 15m, 30m, 1h, 4h, 1d, 1w, 1M',
        },
        timestamp: new Date(),
      });
    }

    // Try cache first
    let candles = await cacheService.getCandles(marketId, interval);

    if (!candles) {
      candles = await db.getCandles(marketId, interval, fromDate, toDate, limitNum);

      // Cache for 5 seconds for "live", 5 minutes for older historical
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
      const ttl = toDate && toDate < oneHourAgo ? 300 : 5;

      await cacheService.setCandles(marketId, interval, candles, ttl);
    }

    // TradingView-compatible format
    const ohlcvData = candles.map((c) => ({
      time: c.openTime.getTime(),
      open: c.open.toNumber(),
      high: c.high.toNumber(),
      low: c.low.toNumber(),
      close: c.close.toNumber(),
      volume: c.volume.toNumber(),
    }));

    const response: ApiResponse<typeof ohlcvData> = {
      success: true,
      data: ohlcvData,
      timestamp: new Date(),
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching OHLCV data:', error);
    res.status(500).json({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch OHLCV data' },
      timestamp: new Date(),
    });
  }
});

// Get recent trades
router.get('/markets/:marketId/trades', async (req: Request, res: Response) => {
  try {
    const marketId = safeUpperMarketId(req.params.marketId);
    const limitNum = Math.min(parseIntSafe(req.query.limit, 100), 1000);
    const sinceDate = parseOptionalDate(req.query.since);

    let trades: Trade[] = [];

    // Try cache first (Redis Streams)
    const cachedTrades = await cacheService.getRecentTrades(marketId, limitNum);
    if (cachedTrades.length > 0) {
      trades = cachedTrades;
    } else {
      trades = sinceDate
        ? await db.getTradesSince(marketId, sinceDate, limitNum)
        : await db.getRecentTrades(marketId, limitNum);
    }

    const tradesData = trades.map((t) => ({
      id: t.id,
      price: t.price.toString(),
      amount: t.amount.toString(),
      side: t.side,
      timestamp: t.timestamp.getTime(),
    }));

    const response: ApiResponse<typeof tradesData> = {
      success: true,
      data: tradesData,
      timestamp: new Date(),
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching trades:', error);
    res.status(500).json({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch trades' },
      timestamp: new Date(),
    });
  }
});

// Get market ticker
router.get('/markets/:marketId/ticker', async (req: Request, res: Response) => {
  try {
    const marketId = safeUpperMarketId(req.params.marketId);

    // Try cache first
    let ticker = await cacheService.getTicker(marketId);

    if (!ticker) {
      // Prefer 24h window query (more accurate than pulling a fixed 1000 and filtering)
      const now = new Date();
      const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);

      const trades24h = await db.getTradesSince(marketId, yesterday, 5000);

      // If no trades in last 24h, fall back to recent trades for "last"
      if (trades24h.length === 0) {
        const recent = await db.getRecentTrades(marketId, 1);
        if (recent.length === 0) {
          return res.status(404).json({
            success: false,
            error: { code: 'NO_TRADES', message: 'No trades found for this market' },
            timestamp: new Date(),
          });
        }

        // If there are trades historically but none in 24h, set minimal ticker
        const last = recent[0].price;
        ticker = {
          marketId,
          timestamp: now,
          last,
          bid: new Decimal(0),
          ask: new Decimal(0),
          high24h: last,
          low24h: last,
          volume24h: new Decimal(0),
          quoteVolume24h: new Decimal(0),
          change24h: new Decimal(0),
          changePercent24h: new Decimal(0),
          trades24h: 0,
        };
      } else {
        // trades24h should be DESC by timestamp from db.getTradesSince()
        const newest = trades24h[0];
        const oldest = trades24h[trades24h.length - 1];

        const prices = trades24h.map((t) => t.price);
        const last = newest.price;
        const open24h = oldest.price;

        const change = last.sub(open24h);
        const changePct = open24h.eq(0) ? new Decimal(0) : change.div(open24h).mul(100);

        // Optional: use cached orderbook to set bid/ask if available
        const ob = await cacheService.getOrderBook(marketId);
        const bid = ob?.bids?.[0]?.price ?? new Decimal(0);
        const ask = ob?.asks?.[0]?.price ?? new Decimal(0);

        ticker = {
          marketId,
          timestamp: now,
          last,
          bid,
          ask,
          high24h: Decimal.max(...prices),
          low24h: Decimal.min(...prices),
          volume24h: trades24h.reduce((sum, t) => sum.add(t.amount), new Decimal(0)),
          quoteVolume24h: trades24h.reduce((sum, t) => sum.add(t.total), new Decimal(0)),
          change24h: change,
          changePercent24h: changePct,
          trades24h: trades24h.length,
        };
      }

      await cacheService.setTicker(marketId, ticker, 5); // 5 seconds
    }

    const tickerData = {
      market: ticker.marketId,
      last: ticker.last.toString(),
      bid: ticker.bid.toString(),
      ask: ticker.ask.toString(),
      high24h: ticker.high24h.toString(),
      low24h: ticker.low24h.toString(),
      volume24h: ticker.volume24h.toString(),
      quoteVolume24h: (ticker as any).quoteVolume24h?.toString?.() ?? '0',
      change24h: ticker.change24h.toString(),
      changePercent24h: ticker.changePercent24h.toString(),
      trades24h: (ticker as any).trades24h ?? 0,
      timestamp: ticker.timestamp.getTime(),
    };

    const response: ApiResponse<typeof tickerData> = {
      success: true,
      data: tickerData,
      timestamp: new Date(),
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching ticker:', error);
    res.status(500).json({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch ticker' },
      timestamp: new Date(),
    });
  }
});

// Get order book depth (if available)
router.get('/markets/:marketId/depth', async (req: Request, res: Response) => {
  try {
    const marketId = safeUpperMarketId(req.params.marketId);
    const limitNum = Math.min(parseIntSafe(req.query.limit, 20), 100);

    const orderBook = await cacheService.getOrderBook(marketId);

    if (!orderBook) {
      const response: ApiResponse<any> = {
        success: true,
        data: { bids: [], asks: [], timestamp: Date.now() },
        timestamp: new Date(),
      };
      return res.json(response);
    }

    const depthData = {
      bids: orderBook.bids.slice(0, limitNum).map((lvl) => [lvl.price.toString(), lvl.amount.toString()]),
      asks: orderBook.asks.slice(0, limitNum).map((lvl) => [lvl.price.toString(), lvl.amount.toString()]),
      timestamp: orderBook.timestamp.getTime(),
    };

    const response: ApiResponse<typeof depthData> = {
      success: true,
      data: depthData,
      timestamp: new Date(),
    };

    res.json(response);
  } catch (error) {
    console.error('Error fetching depth:', error);
    res.status(500).json({
      success: false,
      error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch market depth' },
      timestamp: new Date(),
    });
  }
});

export { router as chartController };
